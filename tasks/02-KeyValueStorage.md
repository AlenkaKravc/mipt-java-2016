
## 2. Работа с бинарными данными

Внимание! Это задание - черновик.

### Файловая база данных
Нужно реализовать библиотеку для работы с файловым хранилищем.

Библиотека должна предоставлять реализацию интерфейса [KeyValueStorage](../homework-base/src/main/java/ru/mipt/java2016/homework/base/task2/KeyValueStorage.java).
Также нужно реализовать фабрику [KeyValueStorageFactory](../homework-base/src/main/java/ru/mipt/java2016/homework/base/task2/KeyValueStorageFactory.java),
которая будет порождать объекты хранилища. Также потребуется написать страгтегии сериализации для ключей и значений.

Все данные должны храниться в указанной при создании хранилища директории.
Данные хранятся во множестве файлов, число файлов задается при создании хранилища. Формат имени файла - `fileNNN.db`.
Данные распределяются по файлам по принципу хеш-таблицы по следующей формуле:

```
fileNumber = key.hashCode() % filesCount;
if (fileNumber < 0) fileNumber += filesCount;
```

Данные лежат в бинарном файле следующего формата:

```
Ключ 1, смещение значения 1,
Ключ 2, смещение значения 2,
...
Значение 1, значение 2, ...
```

Ключи внутри файла должны быть отсортированы.

TODO тестирование через юнит-тест

#### Подводные камни

* При запуске приложения нужно убедиться, что директория, в которой предлагается работать, существует, а также что она действительно директория, а не файл.
* При чтении из файлов нужно проверять их валидность, избегать слишком больших и маленьких значений буферов.
* Пустых файлов быть не должно. Если после очередного изменения файл опустел - удалите его.
* Бинарный формат и соотношение ключ-файл должны быть строго соблюдены.
* Неразумно на каждый запрос писать в файл и читать из файла.
* Есть риск, что все значения не влезут в память - подумайте, что прочесть достаточно для работы.

### Механизм потоковой обработки

Нужно адаптировать реализацию файловой базы данных под потоковую обработку данных.
Для этого нужно реализовать интерфейсы [PipeSource](../homework-base/src/main/java/ru/mipt/java2016/homework/base/task2/PipeSource.java) и [PipeSink](../homework-base/src/main/java/ru/mipt/java2016/homework/base/task2/PipeSink.java).

Ваш PipeSink должен читать из базы данных все данные в виде итератора `Iterator<KeyValuePair<K, V>>`.

Ващ PipeSource должен записывать в базу данных все данные из итератора `Iterator<KeyValuePair<K, V>>`.

В качестве примера использования потокового обработчика напишите следующий процесс:

1. Читаем из базы все данные, считаем, что типы ключей и значений - строки.
2. Для каждого значения выполняем [Calculator.calculate()](../homework-base/src/main/java/ru/mipt/java2016/homework/base/task1/Calculator.java). Тип значения меняется на Double.
3. Записываем все пары ключ-значение в другую базу (обратите внимание, формат изменился).

Оформите программу с примером потоковой обработки как main-класс.

TODO тестирование через юнит-тест

### Бонус. Оптимизация асимптотики

Оцените текущую асимптотическую сложность всех операций над хранилищем.
Предложите и реализуйте способ хранения с более эффективными асимтотиками.
